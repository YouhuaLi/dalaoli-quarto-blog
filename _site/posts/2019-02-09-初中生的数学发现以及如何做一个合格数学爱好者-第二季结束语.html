<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2019-02-09">

<title>初中生的数学发现以及如何做一个合格数学爱好者– 第二季结束语 – dalaoli_quarto_blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">dalaoli_quarto_blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">初中生的数学发现以及如何做一个合格数学爱好者– 第二季结束语</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">每周一题</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 9, 2019</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>大家好，我是大老李。这期节目是第二季的最后一期，本来我还有点愁这第二季结束语聊点啥呢，正好前几天,一位署名“上海实验中学中一班陈嘉熙”的听众，联系到我，说他听了我之前一期关于“<a href="https://zhuanlan.zhihu.com/p/52564933">柯克曼女生散步</a>”问题的节目之后，自己有了点发现，让我给看看。</p>
<p>这位陈同学的发现是有关可分解的不平衡区组设计的，简称RBIBD问题，具体含义请回听一下那期柯克曼女生散步问题。在那期节目最后我提到了，我收到另一个署名王本材的听众来信，说他在研究<span class="math inline">\((n^2,n,1)\)</span>这种类型的RBIBD问题。比如n取5的时候，这个问题就相当于问：有25个人，能否找出一种方案，每天每5个一组出去散步，每天5组，连续散步6天。最终6天后，每个人恰好和其他人一起散步一次？</p>
<p>当时我用了些软件查了下这个问题，那个软件提示这个问题的答案是：未知（unknown）：</p>
<figure class="wp-block-image figure">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://pic1.zhimg.com/v2-7b16378929693fd69514619a5c363398_b.png" class="img-fluid figure-img"></p>
<figcaption>enter image description here</figcaption>
</figure>
</div>
</figure>
<p>而这位陈同学来信说他找到了这个问题的解，我起初是有点不相信初中生能做出来的。他一开始给我的是一个具体的构造出行方案的方法，而不是具体结果。而他的方法的文字描述有点复杂，所以我有点怀疑他到底是否找出方案没有。我就让他编个程序，直接打印出具体结果给我看。</p>
<p>没想到第二天他在微信上就把程序发给我了，而且直接给出了全部6天的分组方案，完全正确。当天晚上，我把他的程序改写成python验证（<a href="https://github.com/dalaoli-shuxue/math_misc/blob/master/n2-rbibd/n2-rbibd.py">代码</a>，比较随意，拿去随便改），也完全正确。</p>
<code>python n2-rbibd.py 5 [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]] [[1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24], [5, 10, 15, 20, 25]] [[1, 7, 13, 19, 25], [2, 8, 14, 20, 21], [3, 9, 15, 16, 22], [4, 10, 11, 17, 23], [5, 6, 12, 18, 24]] [[1, 8, 15, 17, 24], [2, 9, 11, 18, 25], [3, 10, 12, 19, 21], [4, 6, 13, 20, 22], [5, 7, 14, 16, 23]] [[1, 9, 12, 20, 23], [2, 10, 13, 16, 24], [3, 6, 14, 17, 25], [4, 7, 15, 18, 21], [5, 8, 11, 19, 22]] [[1, 10, 14, 18, 22], [2, 6, 15, 19, 23], [3, 7, 11, 20, 24], [4, 8, 12, 16, 25], [5, 9, 13, 17, 21]]</code>

<p>更妙的是，他的构造方法对所有n为素数都成立, n为合数时不适用。简单来说就是在一个正方形里尽可能多的找斜线。以下是他发给的word文档节选：</p>
<hr class="wp-block-separator">
<ul>
<li>
我的思路是怎么来的
</li>
</ul>
<figure class="wp-block-image figure">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://pic4.zhimg.com/v2-8510f19d3ea2fd0157bee2bffa1a70ff_b.png" class="img-fluid figure-img"></p>
<figcaption>enter image description here</figcaption>
</figure>
</div>
</figure>
<figure class="wp-block-image figure">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://pic1.zhimg.com/v2-a70bbea8f12291324ea8a40151bf5d28_b.png" class="img-fluid figure-img"></p>
<figcaption>enter image description here</figcaption>
</figure>
</div>
</figure>
<p>首先，我先思考了n=3时的(9,3,1)RBIBD问题。我先把这9个人想象了成一个3*3的正方形。然后第一天的散步方案肯定是{{1,2,3},{4,5,6},{7,8,9}}，所以把九个人如下图分组（以下均使用染色方式分组）</p>
<p>…</p>
<hr class="wp-block-separator">
<p>陈同学的方法是如此简单，所以我就很好奇，难倒之前没有人想到这种方法吗？我就网上好好地搜索了一下，确实没有找到有关这种n为素数的情况下的<span class="math inline">\((n^2,n,1)\)</span> RBIBD构造的论文。</p>
<p>后来我又找到了王本材听众的邮件，他提到过n为素数的情况下是有通解的。我给他发了一份邮件希望他给出这种通解的出处和形式，他很快给了答复给我。我看了下他关于n为质数是的构造方法，与陈同学一样的，而且他说这是他自己发现的。而且王医生也找到了n为合数的一些构造情况，比如n=4和9的情况。他还有一些关于什么样的n可以构造出RBIBD的猜想，目前在写论文，我看他的那个猜想是比较靠谱的，我也很期待他的文章。</p>
<p>所以目前看来，很可能是这种n为质数类型的RBIBD设计太平凡，以至于都没有专门的论文提到它，我也很希望听众里有这方面的专家能给出一些意见。</p>
<p>但尽管陈同学的发现算不上什么惊天动地的大发现，他是目前第一个通过听大老李节目之后，钻研一个问题，能有所发现的，所以我很乐意给他宣传下。其实大老李做节目以来，有一个最大的愿望就是在不久的将来，也许10年以内，中国出一个数学家，能在接受采访时说：我小时候喜欢听“大老李聊数学”，这是最大愿望。</p>
<p>第二大的愿望是，有任何听众，专业非专业的，能听过我的节目后，受启发，钻研某个问题，有所发现的。这位陈同学算第一个，所以我很高兴。而且陈同学只是初中生，这个发现对初中生来说已经很不容易了，值得鼓励！也很感谢王本材听众给我的来信，其实也是他的来信，促使我好好研究了一下柯克曼女生散步问题，并做了那期节目。</p>
<p>说到这里，我也想起来不久前知乎上有高中生声称证明了“歌德巴赫猜想”，但事后毫无意外的被批的体无完肤。所以大老李想聊聊怎么避免“民科”，这种走火入魔的情况。</p>
<p>大老李制作节目过程中深有体会，中文网页里，声称证明了“哥德巴赫猜想”、“孪生素数猜想”、“费马大定理”、“考拉兹猜想”的文章证明多得不胜枚举。本来这期节目标题设想是：“如何做一个合格的数学民科”，但是在中国，“民科”已经成贬义词了，所以我想了下还是说：“如何做一个合格的数学爱好者”。顺便提个想法：现在各种爱好者团体都有一些昵称，这个粉，那个丝的。所以也想请各位听众集思广益，给数学爱好者起一个响亮有意思的名称。如果你有好的提议欢迎留言给我。</p>
<p>言归正传，大老李给你一下忠告，帮你避免调入“民科”的陷阱，总结下来，就是四个“不要”：</p>
<p>首先，不要考虑推翻历史上已经证明过的命题。历史上还没有发生过哪个被证明过的命题，最终发现被证明错误，并且是反命题成立的。</p>
<p>其次，不要考虑去找出已经被认可的证明中的错误。看到网上有人否定安德鲁·怀尔斯对费马大定理的证明，以及哥德尔的不完备原理的证明。这种否定完全是浪费时间。历史上只发生过一次比较出名的被认可的证明后来被否决的事件，即1876年肯普（Alfred Kempe）对“四色定理”的证明。这个证明一开始被认为是对的，但11年后，英国数学家彭西·希伍德（Percy Heawood）发现肯普的证明是有问题的，但肯普的思路可以被用来证明较弱的“五色定理”。自从此事件之后，数学家对一个证明的审核变得十分审慎，宁愿好多年不给结论，也不轻易的说一个证明是正确的。因此100多年以来，只要一个证明被数学圈认可是正确的，就再也没有发生过被推翻的情况。</p>
<p>第三：不要尝试用简单的方法改写历史上已经被证明的，但证明过程极为复杂的命题。比如有人笃信费马留下的一段笔记，认为“费马大定理”有一个“简单”的证明，而去尝试寻找那样的简单证明，那就完全走偏了。历史上确实有一个例子–“素数定理”，先用复杂的方法被证明，后来又被埃尔德什和Atle Selberg 用“初等数学”方法改写了证明。但这个“初等数学”的证明绝不是一个”简单证明”，其对绝大多数业余爱好者来说已经是十分艰深了，以下是这个“初等证明”中用到的一个等式：</p>
<p><span class="math inline">\(\vartheta (x)\log(x)+\sum \limits _{p\leq x}{\log(p)}\ \vartheta \left({\frac {x}{p}}\right)=2x\log(x)+O(x)\)</span></p>
<p>倒是历史上有很多有简单证明的命题不断被人用其他方法证明，比如“勾股定理”。据说勾股定理已有上百种不同的的证明，所以你要发现新的勾股定理证明，也需要先检验是否与前人重复。</p>
<p>第四：不要尝试证明那些非常出名但有几十上百年历史未被证明的命题。这些命题包括但不限于：哥德巴赫猜想，黎曼假设，孪生素数猜想，考拉兹猜想，P/NP问题，以及众多直接关于素数的数论命题。这大概这是很多业余爱好者最难接受的，凭什么我就不能挑战这些问题？但这些问题正是数学里最迷人而危险的领域。它们看起来如此简单，但数学里表述越简单的问题往往越困难。如果一个问题经过欧拉、高斯、黎曼以及当代那么多数学家的心血仍未解决，你就应该对这个问题存有敬畏之心。</p>
<p>你可能会说：历史上不是出现过黑格纳和陆家羲这样的例子，他们以“数学爱好者”的身份，证明了数学上的百年名题，但是一开始却不被认可的例子吗？那是不是说明，我也可能证明比如歌德巴赫猜想，只是我的证明数学家看不懂或者不愿承认呢？</p>
<p>首先，我要说的是黑格纳和陆家羲绝不是民科，他们都至少都读过大学，知道基本的学术规范和研究范式。</p>
<p>其次，他们两人都是非常专一的，用毕生精力研究一个问题，虽然他们不是职业数学家，但是他们在自己研究的这个问题上的水平和理解，绝不亚于任何职业数学家。所以我也劝劝各位，如果你选定了一个数学问题想自己研究，先请你上网搜搜目前关于这个问题的最新研究论文，特别是英文版的也要看。如果你能看懂那些论文的大概意思，理解目前最新的研究成果，你再开始动手不迟。</p>
<p>以上四个“不要”就是我对各位爱好者的逆耳忠言。那要怎么做才是好的呢？我这次给大家一个建议是关于如何提出一个好的数学问题，甚至让它成为一个猜想？是不是提出一个很难的数学家都做不出来的问题就是一个猜想了？但是，提出一个很难的问题很容易，提出一个好的问题却很难。</p>
<p>我给大家一个关于如何提出好的数学问题的五字真言：“精炼而熟虑”，深思熟虑的熟虑。其实这五个字是我从高斯老前辈那里借过来的，这是他一生研究数学的信条。那什么叫“精炼而熟虑”呢？有两个人是最好的榜样，就是埃尔德什（Paul Erdos, 1913-1996）和约翰·康威（John Conway，1937-）。请大家好好去看下他们两人提出的所有已经解决或未解决的猜想，此二人都是提出猜想的大师，特别是埃尔德什。</p>
<figure class="wp-block-image figure">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://pic2.zhimg.com/80/v2-45c3a4020fdec6885ddf41f798eda357_hd.jpg" class="img-fluid figure-img"></p>
<figcaption>enter image description here</figcaption>
</figure>
</div>
</figure>
<p>大老李做节目到现在是深有体会，经常一篇文章看到当中，就提到说：埃尔德什曾经猜想如何如何…另一篇文章看到一半，又是：埃尔德什曾经猜想如何如何…感觉可以提的猜想都被埃尔德什提完了。而且埃尔德什提出的猜想，绝对是体现了“精炼而熟虑”原则。比如我最近看到的一个例子：埃尔德什曾经问这样一个方程是否有整数解：</p>
<p><span class="math inline">\(1^k+2^k+3^k+\cdot\cdot\cdot+(m-1)^k=m^k\)</span></p>
<p>其中m和k都是正整数。k等于1的时候，你当然发现1+2=3就是解。埃尔德什就问你：当k&gt;=2整数有没有整数解呢？k=2时，有一组接近的解：是<span class="math inline">\(3^2+4^2=5^2\)</span>，但是本问题要求方程左边的项是从1的幂次开始的。</p>
<p>这个问题，简单到初中生都能看懂，精炼到极致。而且，你一看到，心理就能涌现出无数种可能的思路，去探究这个问题。而你在至少稍微尝试过一下之后，你会发现你大多数思路都无法达成最终目标。此时，你就会明白，埃尔德什出这题前，他已经都考虑过这些常规思路了，常规是思路无解的。此时，我的脑子里就会浮现出埃尔德什老头窃笑的情景：“哈哈，你这点小伎俩我早就考虑到了，根本走不通：）”，所以这是“熟虑”！</p>
<p>现在可以告诉大家的是，如果以上方程有整数解，那么m要大于<span class="math inline">\(10^{100000}\)</span>，而且据说一位数学家用初等数学方法就证明了这一点，听众当中有能力的大可挑战一下，找一下这个证明。目前这个问题还是为解决的问题，埃尔德什猜想这个方程是无解的。我没查过当初埃尔德什给这个问题悬赏多少钱，但肯定是有悬赏的（埃尔德什爱自己掏钱悬赏数学问题）。</p>
<p>从这个例子中，我希望大家能体会到“精炼且熟虑”这五字真言的含义，体会到什么是好的数学问题。而不要像知乎上有人提的“<span class="math inline">\(1  \times 0=0\)</span>，是因为1的作用还是0的作用？”，“如果进制采用<span class="math inline">\(\pi\)</span>这种无理数做进制单位，是否更好？“这种问题。</p>
<p>好了，以上就是大老李总结的，避免陷入民科的“四个不要”以及“精炼且熟虑原则”。当然，还有一个很好的方法，就是坚持听大老李的节目，可以确保你对数学的认知在科学的轨道上。</p>
<p>我的二季节目就到此结束了，非常感谢众多听众长久支持还有大老李聊数学群里的各位群友。希望大家过一个开心的春节，猪年有空多做数学题。我会休息几个月，公众号的每周一题会继续推送，欢迎参与，第三季再见！</p>
<hr class="wp-block-separator">
<figure class="wp-block-image figure">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://pic4.zhimg.com/80/v2-ea394cf045d754a4633051c5e90c8014_hd.png" class="img-fluid figure-img"></p>
<figcaption>enter image description here</figcaption>
</figure>
</div>
</figure>
<p>在喜马拉雅收听“大老李聊数学“</p>
<p>订阅公众号：dalaoli_shuxue</p>
<p>知乎专栏：https://zhuanlan.zhihu.com/dalaoli-shuxue</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/your-website-url\.example\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>