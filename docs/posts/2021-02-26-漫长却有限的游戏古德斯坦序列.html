<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2021-02-26">

<title>漫长却有限的游戏——古德斯坦序列 – dalaoli_quarto_blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">dalaoli_quarto_blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">漫长却有限的游戏——古德斯坦序列</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">音频讲稿</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 26, 2021</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>不久前我讲过一些<a href="https://zhuanlan.zhihu.com/p/348673044">序数</a>方面的知识，今天跟大家聊一个序数的应用。这个应用本身也是一个非常好玩的大数。关于这个大数，我先回顾一个可能大家已经非常熟悉的，有关国际象棋的故事：</p>
<p>古代印度某个国王很喜欢下国际象棋，他决定给国际象棋的发明者一点奖赏。他就把这个发明者叫到了皇宫来，问他要什么奖赏。这个发明者说：“陛下，我要这样的一个奖励。请你在棋盘的第一个格子里放上一粒麦子，第二格放两粒麦子，第三格放四粒麦子。以此类推，每一格都放上前一格两倍数量的麦子，直到把64格都放满，这就是我要的奖励。”</p>
<figure class="wp-block-image figure">
<img src="https://static01.imgkr.com/temp/bc5d7dcbbd964b338e62868c16f0d592.png" class="img-fluid figure-img">
</figure>
<p>国王一听，这还不简单吗，马上让人来把麦子拿进来，开始往棋盘上放麦子。但是很快，国王发现麦子完全不够用了，填满64格是一个不可能完成的任务。如果你具体算一下大概需要多少麦子的话，你会发现这个奖励需要地球上两千年的麦子产量。</p>
<p>这个故事我小时候看过之后，印象是很深的，它说明人对指数增长的数字大小感受能力是有限的。故事里实际需要的麦子数量，如果写出来也就是<span class="math inline">\(2^{64}-1\)</span>粒麦子，这个数字看上去一点都不大，但是实际大小已经远超过了常人的感受能力了。</p>
<p>那么现在我把这个故事稍微改造下，改成一个拿走麦子的游戏，并且可以构造出一个更大的数字。方法是这样：</p>
<p>一开始先在棋盘的64格里，每一格放一粒麦子。然后按如下规则，从棋盘上拿走麦子。每一步执行如下的操作：</p>
<ol start="0">
<li>
开始时步数为1.
</li>
<li>
如果第一个格里有麦子，则从第一格拿走1粒麦子。当前步骤完成，步数增加1，重复执行下一步。
</li>
<li>
如果第一格里没有麦子，则从第二格“借麦子”。借麦子的规则是：如果当前在执行第n步，第a格里的麦子，可以转换成第a-1格里的n粒麦子。比如第二格里的1粒麦子，可以转换成第一格里的n粒麦子。第三格里的1粒麦子，可以转换成第二格里的n粒麦子等等。其实这个规则就是类似于减法借位规则，只不过借位不是固定以10进制为转换单位，而是以当前步数为单位。不管怎样，借位转换完成后，当第一个里有麦子了，那么就从第一格里拿走一粒麦子，当前步骤完成，步数增加1，重复执行下一步。
</li>
</ol>
<p>稍微推演下这个流程：</p>
<figure class="wp-block-image figure">
<img src="https://static01.imgkr.com/temp/9f62496ff7ad48eba9bdb70a0567572e.png" class="img-fluid figure-img">
</figure>
<p>(上图：拿走麦子游戏中，对1-4格在前65步情况的推演。数字为该步骤开始时，格子里的麦子数)</p>
<p>第一步时，第一格有一粒麦子，那么直接拿走，进入第二步。</p>
<p>第二步时，第一格没有麦子，需要向第二格借。按规则，因为现在是第二步，所以第二格的那一粒麦子可以转换为第一格的2粒麦子。那么就拿走第二格的那粒麦子，在第一格放入两粒麦子。现在第一格有麦子了，那么从第一个拿走一粒麦子。</p>
<p>第三步：第一格里还有一粒麦子，直接拿走，进入第四步。</p>
<p>第四步时：第一格没有麦子了，向第二格借。第二格此时也没有麦子了，那么要向第三格借。则拿走第三格的一粒麦子，转换成第二格的4粒麦子，因为现在是第4步，转换比例是1比4。再拿走第二格的1粒，转换成第一格的4粒麦子。此时再从第一格拿走1粒麦子。这一步结束。结束状态就是第三格空了，第二格有3粒麦子，第一格也有3粒麦子。</p>
<p>之后的推演就不一一解说了，可以想象到，到第8步时，第一格又空了，要向第二格借。此后每次到了<span class="math inline">\(2^n\)</span>步时，第一个格会为空，需要向第二格借。每次约到了<span class="math inline">\(2^{2^n}\)</span>步（读者可以自己考虑推导一下准确的表达式）时，第一格和第二格会空，需要向第三格借，等等。</p>
<p>现在的问题是，如此操作，有可能把棋盘上所有麦子拿空吗？稍微想一下，你会发现肯定能拿空。</p>
<p>因为无论第一格有多少粒麦子，总能拿空。第一格拿空的话，总需要向第二格借。那么无论第二格有多少粒麦子，也迟早能拿空，第二格也总需要向上一格借。如此，有点像数学归纳法，我们知道第64格也总能被拿空。第64格能拿空，后面的格子自然也会拿空，总体必然能在有限步骤内结束。</p>
<p>如果要定量分析的话，也很简单。你会发现其实棋盘在任何一步的状态其实是表示了一个64位的数字，这个数字的进制数就是当前的步数。比如第10步的时候，这个棋盘第64格里的1粒麦子就相当于<span class="math inline">\(10^{63}\)</span>粒麦子，第11步的时候就变成<span class="math inline">\(11^{63}\)</span>粒。所以，这个棋盘就相当于一个64位的数字，但是进制数是每步递增1，所以整个数字一开始增加是非常快的。</p>
<p>但你也会发现，这个过程中，最高位的数字是不会增加，只是底数在增加，所以它迟早最会被拿空。虽然需要的步数大的非常恐怖了，但是还是有限的。</p>
<p>那么以上游戏中，我们的整个操作步骤，等价于“弱古德斯坦序列”。</p>
<hr class="wp-block-separator">
<p>对于任意正整数n，第n个弱古德斯坦序列 {<span class="math inline">\(g_1\)</span>, <span class="math inline">\(g_2\)</span>, <span class="math inline">\(g_3\)</span>, …}按如下方式定义：</p>
<p><span class="math inline">\(g_1 = n\)</span></p>
<p>对于k &gt; 1，将<span class="math inline">\(g_{k-1}\)</span>写成k进制表示，然后将其视为k+1进制的数，最后减去1，得到<span class="math inline">\(g_k\)</span>。</p>
<p>当<span class="math inline">\(g_k\)</span>变为0时序列终止。</p>
<p>例如，第6个弱古德斯坦序列为{6, 11, 17, 25, …}：</p>
<p><span class="math inline">\(g_1 = 6\)</span></p>
<p><span class="math inline">\(g_2 = 11\)</span>，因为<span class="math inline">\(6 = 110_2\)</span> (下标的2表示2进制表示)，然后<span class="math inline">\(110_3 = 12\)</span>，最后<span class="math inline">\(12 - 1 = 11\)</span>。</p>
<p><span class="math inline">\(g_3 = 17\)</span>，因为<span class="math inline">\(11 = 102_3\)</span>，然后<span class="math inline">\(102_4 = 18\)</span>，最后<span class="math inline">\(18 - 1 = 17\)</span>。</p>
<p><span class="math inline">\(g_4 = 25\)</span>，因为<span class="math inline">\(17 = 101_4\)</span>，然后<span class="math inline">\(101_5 = 26\)</span>，最后<span class="math inline">\(26 - 1 = 25\)</span>。</p>
<p>依此类推。</p>
<p>如果用g(n)表示以n开始的弱古德斯坦序列的长度，即游戏结束所需步数，则有如下上下界：</p>
<p><span class="math inline">\(g(7)=2045\)</span></p>
<p><span class="math inline">\(g(8)=3 \times 2^{402,653,211}-3\)</span></p>
<p>$2^{n-1} n &lt;g(2<sup>n)&lt;2</sup>{n} n $</p>
<p>(“<span class="math inline">\(\uparrow\)</span>” 为 “高德纳箭号表示法”)</p>
<hr class="wp-block-separator">
<p>当然它是一个增长很快的大数序列，但是既然它叫“弱古德斯坦序列”，那么必然还有一个比它更强的原版的古德斯坦序列。</p>
<p>原版的古德斯坦序列是对弱古德斯坦序列进行这样一个扩展：</p>
<p>假设一开始的国际级象棋棋盘的每个格子里，又有一个更小的有若干格子的棋盘，这个小棋盘的每一格里，又可以嵌套若干层更小的棋盘，其他规则不变，那么情况会如何？</p>
<p>稍微思索一下，你会发现这样一个惊人事实：</p>
<p>无论一开始的棋盘有多少个格子，每个格子里嵌套了多少重棋盘，在每个格子里放入了多少粒麦子，只要一开始的状态是确定，那么最终总能拿走所有麦子！</p>
<figure class="wp-block-image figure">
<img src="https://imgkr2.cn-bj.ufileos.com/f85c45da-0dc0-40a5-91c1-a090dd123ceb.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=1ITp8YYr6UhvhrckkCbGZuT676c%253D&amp;Expires=1614396769" class="img-fluid figure-img">
</figure>
<p>其实这个道理还是很容易想的，因为我们分析过弱古德斯坦序列的情况，我们知道只要任意一格能拿完，那么它的上一格就能拿完。上一格能拿完，这一层的棋盘就能拿完。这一层能拿完，那么就表示承托这一层棋盘的格子能拿完，那么就又回到开始的推理了。这一层层递归推理下去，整个棋盘必能拿完。</p>
<hr class="wp-block-separator">
<p>数学中古德斯坦序列的确切构造方法（文字部分参考了 https://zhuanlan.zhihu.com/p/106647826）：</p>
<p>（1）随便给出一个自然数，比如本文题图中的那个数——100，设为<span class="math inline">\(M_1\)</span> ；</p>
<p>（2）把<span class="math inline">\(M_1\)</span> 表示成以2为底数的各个幂的和，也就是表示为二进制的形式；然后把所有的大于2的指数也表示成二进制的形式；如果指数上的指数还有大于2的，也将其表示为二进制的形式，以此类推，直到出现的所有数都小于等于2:</p>
<p>$M_1=100 = 2<sup>{6}+2</sup>{5}+2<sup>2=2</sup>{2^{2} + 2} + 2<sup>{2</sup>{2} + 1} + 2^{2} $</p>
<p>（3）把（2）里面表达形式中的数字2替换为3，然后把得到的新的数再减去1，得到<span class="math inline">\(M_2\)</span>:</p>
<p><span class="math inline">\(M_2=3^{3^{3} + 3} + 3^{3^{3} + 1} + 3^{3}-1\)</span></p>
<p>$=3<sup>{3</sup>{3} + 3} + 3<sup>{3</sup>{3} + 1} + 2^{2} + 2 + 2 $</p>
<p><span class="math inline">\(=228767924549636\)</span></p>
<p>（4）再把得到的<span class="math inline">\(M_2\)</span>表示成以3为底数的各个幂的和，也就是表示为三进制的形式；然后把所有大于3的指数也表示成三进制的形式；以此类推，直到出现的所有数都小于等于3；</p>
<p>（5）把（4）中的表达形式中的数字3替换为4，然后把得到的新的数再减去1，得到<span class="math inline">\(M_3\)</span>；</p>
<p><span class="math inline">\(M_3=4^{4^{4} + 4} + 4^{4^{4} + 1} + 2\cdot 4^{2} + 2\cdot 4\)</span></p>
<p><span class="math inline">\(+ 2\cdot 1 -1\)</span></p>
<p>（6）一直按照这种模式做下去……，得到的数列<span class="math inline">\({M_{1}, M_{2}, M_{3}, \ldots \ldots}\)</span>被称为以<span class="math inline">\(M_1\)</span> 为初始值的古德斯坦数列；</p>
<p>（7）古德斯坦定理预言，无论初始值是哪个自然数，古德斯坦数列都会在有限步之后收敛到 0 ！</p>
<p>如果G(n)记作以n开始的古德斯坦序列的长度，那么n=1到10时，有如下上下界：</p>
<figure class="wp-block-image figure">
<img src="https://imgkr2.cn-bj.ufileos.com/9f583c50-456b-4fcc-b43d-7f9c7b5a64ba.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=DBR3CG5CzPqahvhJ9DVXTf%252FduHs%253D&amp;Expires=1614396700" class="img-fluid figure-img">
</figure>
<hr class="wp-block-separator">
<p>更有意思的一点是，古德斯坦序列有一个性质，它的有限性在皮亚诺算术公理系统中是无法证明的。这一点粗看有点令人惊讶，因为之前用那种启发性的思考，我们已经可以相信这个拿走麦子的游戏可以在有限步骤内结束。但如果仔细想想，你还是能发现它不能用皮亚诺算术证明的蛛丝马迹。</p>
<hr class="wp-block-separator">
<p>皮亚诺算术公理介绍（转自维基百科）：</p>
<p>皮亚诺的这五条公理用非形式化的方法叙述如下：</p>
<ol>
<li>
0是自然数；
</li>
<li>
每一个确定的自然数a，都有一个确定的后继数a’ ，a’ 也是自然数；
</li>
<li>
对于每个自然数b、c，b=c当且仅当b的后继数=c的后继数；
</li>
<li>
0不是任何自然数的后继数；
</li>
<li>
任意关于自然数的命题，如果证明：它对自然数0是真的，且假定它对自然数a为真时，可以证明对a’ 也真。那么，命题对所有自然数都真。
</li>
</ol>
<p>其中，一个数的后继数指紧接在这个数后面的数，例如，0的后继数是1，1的后继数是2等等；公理5保证了数学归纳法的正确性，从而被称为归纳法原理。</p>
<hr class="wp-block-separator">
<p>对这种命题，你可能直接能想到的就是数学归纳法。数学归纳法的基本方法就是，对某个命题在n-1的情况你假设命题成立，然后考虑在n的情况，命题仍然成立。 但是对这个拿走麦子的游戏，有个问题是，无法准确的说出n-1和n的情况到底是啥？因为每个棋盘上的每个格子里可能存在另一个拿走麦子的游戏，这种层层嵌套的结构，形成了一种你中有我，我中有你的形式，使得用数学归纳法的时候总是陷入循环论证的困境。</p>
<p>就是说，当假设n-1的成立的时候，似乎就是在假设原命题成立了，这是不允许的。所以皮亚诺算数公理证明不出这个命题。</p>
<p>而如果<a href="https://zhuanlan.zhihu.com/p/348673044">序数</a>理论的话，证明古德斯坦序列的有限性则是出奇得简单。这里我们要用到序数的两个简单性质：</p>
<p>第一个：序数是良序集。也就是序数本身都可以比较大小，并且任何一组序数在一起比较少时，总有一个最小的序数。这个性质有一个推论：序数序列中，不存在无穷递降链。当把一群序数从大到小排列，那么这个序列就叫<strong>递降链</strong>，且这个递降序列长度必然是有限的，因为总有一个最小的序数。这个性质也是所有良序集的性质，即：<strong>良序集中不存在无穷递降链</strong>。</p>
<p>第二：序数可以做加法和乘法运算，而且运算规则与我们的常规熟悉很像。但我们要特别关注<span class="math inline">\(\omega\)</span>这个序数。<span class="math inline">\(\omega\)</span>这个序数是最小的一个无穷序数，它比所有的有穷序数都大，也就是“比所有的自然数都大”，这使它在比大小时，大小关系的判定上非常简便。</p>
<p>那我们看看怎么用序数证明那个拿走麦子的游戏可以在有限步骤内结束。仍以之前<span class="math inline">\(M_1=100\)</span>的情况为例。</p>
<p>那么我们考虑对这个数列的每一个数，如果把底数换成序数里的<span class="math inline">\(\omega\)</span>会怎样？并且我们比较一下变换前的数字和改成<span class="math inline">\(\omega\)</span>为底的数字的大小。</p>
<p><span class="math inline">\(M_1=100 = 2^{6}+2^{5}+2^2=\)</span></p>
<p>$2<sup>{2</sup>{2} + 2} + 2<sup>{2</sup>{2} + 1} + 2^{2} $</p>
<p>底数换成<span class="math inline">\(\omega\)</span>后：</p>
<p>$O_1=<sup>{</sup>{} + } + <sup>{</sup>{} + 1} + ^{} $</p>
<p>原先的<span class="math inline">\(M_2\)</span>:</p>
<p><span class="math inline">\(M_2=3^{3^{3} + 3} + 3^{3^{3} + 1} + 3^{3}-1\)</span></p>
<p>底数换成<span class="math inline">\(\omega\)</span>后：</p>
<p><span class="math inline">\(O_2=\omega^{\omega^{\omega} + \omega} + \omega^{\omega^{\omega} + 1} + \omega^{\omega}-1\)</span></p>
<p>原先的<span class="math inline">\(M_3\)</span>:</p>
<p><span class="math inline">\(M_3=4^{4^{4} + 4} + 4^{4^{4} + 1} + 2\cdot 4^{2} + 2\cdot 4 + 1\)</span></p>
<p>底数换成<span class="math inline">\(\omega\)</span>后:</p>
<p><span class="math inline">\(O_3=\omega^{\omega^{\omega} + \omega} + \omega^{\omega^{\omega} + 1} + 2\cdot \omega^{2} + 2\cdot \omega +1\)</span></p>
<p>原版游戏的每一步的<span class="math inline">\(M_n\)</span>，当改成<span class="math inline">\(\omega\)</span>为底时，它都会小于对应的<span class="math inline">\(O_n\)</span>。</p>
<p>那么再看一下转换过后的<span class="math inline">\(O_n\)</span>序列。你会发现，因为每一次的减一操作，它构成了一个递降序列！</p>
<p>前面说了良序集有个特性，不存在无穷的递降序列，那么就说明<span class="math inline">\(O_n\)</span>序列只能是有限长度的。</p>
<p>而一个正数构成的数列<span class="math inline">\(M_n\)</span>的每一项都小于另一个数列<span class="math inline">\(O_n\)</span>，且<span class="math inline">\(O_n\)</span>长度是有限的，那只能说明<span class="math inline">\(M_n\)</span>也是有限长度的，这样古德斯坦序列的有限性得证！</p>
<p>从以上过程中，我们会发现序数理论是非常有用，它甚至能证明皮亚诺算数中不能证明的命题，<strong>比全体自然数更大的数是有用的</strong>！这是非常令人吃惊但有意思的事情。</p>
<p>更有意思的是序数理论还能帮我们做定量分析。从之前的分析你可以看出，在古德斯坦序列中，每次底数的增加完全可以不是递增1的模式。实际上，对任何递增的自然数序列<span class="math inline">\({a_{1}, a_{2}, a_{3}, \ldots \ldots}\)</span>，在古德斯坦序列中，底数以<span class="math inline">\(a_n\)</span>的方式增加，最终还是会在有限步骤内会到0.</p>
<p>最后解答一个问题，既然皮亚诺算术公理不能证明古德斯坦序列有限，那在以上的证明中一定用到了皮亚诺算术里没有的公理。这个公理是啥呢？</p>
<p>这个公理就是对皮亚诺算术里的“数学归纳法”的扩展。皮亚诺算术公理中，只说数学归纳法对自然数有效，而没有说对序数集有效。而之前的证明用到的一个前提就是，数学归纳法可对包含<span class="math inline">\(\omega\)</span>，及直到<span class="math inline">\(\omega\)</span>幂次的序数的情况都有效，这是皮亚诺算术公理没有的。</p>
<p>这种数学归纳法数数学里有个名称：叫超限或者超穷归纳法(transfinite induction)，就是超越无穷大之后的归纳法。有兴趣的可以自行研究一下。</p>
<p>总结：</p>
<p>文章中向大家介绍一个拿走麦子的游戏，这个游戏虽然步骤长，但却总是有限的。甚至游戏本身可以像套娃一样嵌套，它仍然是有限步骤内可以结束的游戏。这个游戏等价于古德斯坦序列。</p>
<p>古德斯坦序列的有限性，已经不能用皮亚诺算术公理系统来证明，但却可以用来序数理论非常简单的证明，这是序数理论的一个强大之处。</p>
<p>参考资料:</p>
<p>https://zh.wikipedia.org/zh/%E5%8F%A4%E5%BE%B7%E6%96%AF%E5%9D%A6%E5%AE%9A%E7%90%86</p>
<p>http://blog.kleinproject.org/?p=674</p>
<p>https://googology.wikia.org/wiki/Goodstein_sequence</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/your-website-url\.example\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>